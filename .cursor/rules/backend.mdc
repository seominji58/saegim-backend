---
description: ìƒˆê¹€(Saegim) ë°±ì—”ë“œ ê°œë°œ ê·œì¹™ - FastAPI + SQLModel + PostgreSQL + Redis
globs:
  - 'app/**/*.py'
  - '*.py'
  - 'alembic/**/*.py'
  - 'tests/**/*.py'
  - 'requirements*.txt'
  - 'pyproject.toml'
  - 'Dockerfile'
  - 'docker-compose*.yml'
excludeGlobs:
  - '__pycache__/**'
  - '.venv/**'
  - 'venv/**'
  - '.env*'
  - '*.pyc'
  - '*.pyo'
  - '*.pyd'
  - '.pytest_cache/**'
  - '.mypy_cache/**'
alwaysApply: false
---

# ìƒˆê¹€(Saegim) Backend Development Rules

## ğŸ¯ í”„ë¡œì íŠ¸ ê°œìš”

- **ì„œë¹„ìŠ¤ëª…**: ìƒˆê¹€(Saegim) - ê°ì„± AI ë‹¤ì´ì–´ë¦¬
- **ê¸°ìˆ  ìŠ¤íƒ**: FastAPI 0.100+ + Python 3.11+ + SQLModel + PostgreSQL 14+ + Redis 7.x
- **í”„ë¡ íŠ¸ì—”ë“œ**: Next.js 15 (ë³„ë„ ì„œë²„)
- **ì–¸ì–´**: í•œêµ­ì–´ ê¸°ë°˜, ì˜ì–´ ì½”ë“œ/ë¬¸ì„œ
- **ì•„í‚¤í…ì²˜**: RESTful API, ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì¤€ë¹„

## ğŸ“ ë””ë ‰í„°ë¦¬ êµ¬ì¡° (app/ ê¸°ë°˜)

```
app/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ main.py              # FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ ì§„ì…ì 
â”œâ”€â”€ api/                 # API ë¼ìš°í„°
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ auth.py         # ì†Œì…œ ì¸ì¦ ê´€ë ¨ API
â”‚   â”œâ”€â”€ diary.py        # ë‹¤ì´ì–´ë¦¬ CRUD API
â”‚   â”œâ”€â”€ ai.py           # AI ê¸€ê·€ ìƒì„± API
â”‚   â”œâ”€â”€ image.py        # ì´ë¯¸ì§€ ì—…ë¡œë“œ/ì²˜ë¦¬ API
â”‚   â”œâ”€â”€ notification.py # ì•Œë¦¼ ê´€ë ¨ API
â”‚   â””â”€â”€ health.py       # í—¬ìŠ¤ì²´í¬
â”œâ”€â”€ core/               # í•µì‹¬ ì„¤ì • ë° ì˜ì¡´ì„±
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ config.py       # í™˜ê²½ ì„¤ì • (Pydantic Settings)
â”‚   â”œâ”€â”€ deps.py         # ì˜ì¡´ì„± ì£¼ì…
â”‚   â””â”€â”€ security.py     # JWT, ì•”í˜¸í™” ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ db/                 # ë°ì´í„°ë² ì´ìŠ¤ ê´€ë ¨
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ database.py     # SQLModel ì—”ì§„, ì„¸ì…˜ ê´€ë¦¬
â”‚   â””â”€â”€ init_db.py      # ì´ˆê¸° ë°ì´í„° ìƒì„±
â”œâ”€â”€ models/             # SQLModel ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py         # ê¸°ë³¸ ëª¨ë¸ í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ user.py         # ì‚¬ìš©ì ëª¨ë¸
â”‚   â”œâ”€â”€ diary.py        # ë‹¤ì´ì–´ë¦¬ ëª¨ë¸
â”‚   â”œâ”€â”€ image.py        # ì´ë¯¸ì§€ ëª¨ë¸
â”‚   â”œâ”€â”€ notification.py # ì•Œë¦¼ ëª¨ë¸
â”‚   â””â”€â”€ ai_usage.py     # AI ì‚¬ìš© ë¡œê·¸ ëª¨ë¸
â”œâ”€â”€ schemas/            # Pydantic API ìŠ¤í‚¤ë§ˆ
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py         # ê¸°ë³¸ ì‘ë‹µ ìŠ¤í‚¤ë§ˆ
â”‚   â”œâ”€â”€ user.py         # ì‚¬ìš©ì ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ
â”‚   â”œâ”€â”€ diary.py        # ë‹¤ì´ì–´ë¦¬ ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ
â”‚   â”œâ”€â”€ ai.py           # AI ê´€ë ¨ ìŠ¤í‚¤ë§ˆ
â”‚   â””â”€â”€ image.py        # ì´ë¯¸ì§€ ê´€ë ¨ ìŠ¤í‚¤ë§ˆ
â”œâ”€â”€ services/           # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ auth.py         # ì¸ì¦ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ diary.py        # ë‹¤ì´ì–´ë¦¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”œâ”€â”€ ai.py           # AI ì„œë¹„ìŠ¤ ì—°ë™
â”‚   â”œâ”€â”€ image.py        # ì´ë¯¸ì§€ ì²˜ë¦¬ ì„œë¹„ìŠ¤
â”‚   â””â”€â”€ notification.py # ì•Œë¦¼ ì„œë¹„ìŠ¤
â””â”€â”€ utils/              # ìœ í‹¸ë¦¬í‹°
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ encryption.py   # ì•”í˜¸í™” ìœ í‹¸ë¦¬í‹°
    â”œâ”€â”€ validators.py   # ì…ë ¥ ê²€ì¦
    â””â”€â”€ helpers.py      # ì¼ë°˜ í—¬í¼ í•¨ìˆ˜
```

## ğŸ“ ë„¤ì´ë° ì»¨ë²¤ì…˜

### íŒŒì¼/í´ë”

- íŒŒì¼: `snake_case.py` (ì˜ˆ: `auth_service.py`, `diary_model.py`)
- í´ë”: `snake_case` (ì˜ˆ: `api/`, `core/`, `services/`)
- í…ŒìŠ¤íŠ¸ íŒŒì¼: `test_*.py` (ì˜ˆ: `test_auth.py`)

### ì½”ë“œ

- **í´ë˜ìŠ¤**: `PascalCase` (ì˜ˆ: `DiaryCreate`, `UserModel`, `AuthService`)
- **í•¨ìˆ˜/ë³€ìˆ˜**: `snake_case` (ì˜ˆ: `get_current_user`, `diary_count`)
- **ìƒìˆ˜**: `UPPER_SNAKE_CASE` (ì˜ˆ: `DATABASE_URL`, `SECRET_KEY`)
- **ì—´ê±°í˜•**: `PascalCase` + ê°’ì€ `snake_case` (ì˜ˆ: `EmotionType.happy`)
- **SQLModel ëª¨ë¸**: `PascalCase` (ì˜ˆ: `User`, `DiaryEntry`)
- **Pydantic ìŠ¤í‚¤ë§ˆ**: `PascalCase` + ì ‘ë¯¸ì‚¬ (ì˜ˆ: `UserCreate`, `DiaryResponse`)

## âš¡ FastAPI ê·œì¹™

### ì• í”Œë¦¬ì¼€ì´ì…˜ êµ¬ì¡°

```python
# âœ… ì˜¬ë°”ë¥¸ FastAPI ì•± êµ¬ì¡°
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from app.core.config import settings
from app.api import auth, diary, ai, image

app = FastAPI(
    title="ìƒˆê¹€ API",
    description="ê°ì„± AI ë‹¤ì´ì–´ë¦¬ ë°±ì—”ë“œ API",
    version="1.0.0",
    openapi_url="/openapi.json" if settings.ENVIRONMENT == "development" else None
)

# ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_HOSTS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

# ë¼ìš°í„° ë“±ë¡
app.include_router(auth.router, prefix="/api/auth", tags=["auth"])
app.include_router(diary.router, prefix="/api/diary", tags=["diary"])

# âŒ ì˜ëª»ëœ íŒ¨í„´
app = FastAPI()  # ë©”íƒ€ë°ì´í„° ëˆ„ë½
@app.get("/")    # ë¼ìš°í„° ì—†ì´ ì§ì ‘ ì •ì˜
```

### API ë¼ìš°í„° íŒ¨í„´

```python
# âœ… ì˜¬ë°”ë¥¸ ë¼ìš°í„° íŒ¨í„´
from fastapi import APIRouter, Depends, HTTPException, status
from sqlmodel import Session
from app.core.deps import get_current_user, get_session
from app.models.user import User
from app.schemas.diary import DiaryCreate, DiaryResponse
from app.services.diary import DiaryService

router = APIRouter()

@router.post("/", response_model=DiaryResponse, status_code=status.HTTP_201_CREATED)
async def create_diary(
    *,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user),
    diary_in: DiaryCreate,
) -> DiaryResponse:
    """ë‹¤ì´ì–´ë¦¬ ìƒì„±"""
    diary_service = DiaryService(session)
    diary = await diary_service.create_diary(user_id=current_user.id, diary_in=diary_in)
    return DiaryResponse.from_orm(diary)

# âŒ ì˜ëª»ëœ íŒ¨í„´
@router.post("/diary")  # response_model, status_code ëˆ„ë½
def create_diary(data: dict):  # íƒ€ì… íŒíŠ¸ ë¶€ì¡±
    pass
```

### ì˜ì¡´ì„± ì£¼ì… íŒ¨í„´

```python
# âœ… ì˜¬ë°”ë¥¸ ì˜ì¡´ì„± ì£¼ì… íŒ¨í„´
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlmodel import Session, select
from app.core.database import get_session
from app.models.user import User
from app.core.security import decode_access_token

security = HTTPBearer()

async def get_current_user(
    session: Session = Depends(get_session),
    token: HTTPAuthorizationCredentials = Depends(security),
) -> User:
    """í˜„ì¬ ì‚¬ìš©ì ì¡°íšŒ"""
    try:
        payload = decode_access_token(token.credentials)
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="ìœ íš¨í•˜ì§€ ì•Šì€ í† í°"
            )
        
        user = session.get(User, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"
            )
        return user
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="í† í° ê²€ì¦ ì‹¤íŒ¨"
        )
```

## ğŸ—„ï¸ SQLModel ë°ì´í„°ë² ì´ìŠ¤ ê·œì¹™

### ëª¨ë¸ ì •ì˜ íŒ¨í„´

```python
# âœ… ì˜¬ë°”ë¥¸ SQLModel ëª¨ë¸ íŒ¨í„´
from typing import Optional, List
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from app.models.base import BaseModel

class DiaryBase(SQLModel):
    """ë‹¤ì´ì–´ë¦¬ ê¸°ë³¸ ëª¨ë¸"""
    title: str = Field(max_length=255, index=True)
    content: str = Field()
    user_emotion: Optional[str] = Field(max_length=20, index=True)
    ai_emotion: Optional[str] = Field(max_length=20)
    ai_emotion_confidence: Optional[float] = Field(ge=0.0, le=1.0)

class DiaryEntry(DiaryBase, BaseModel, table=True):
    """ë‹¤ì´ì–´ë¦¬ í…Œì´ë¸” ëª¨ë¸"""
    __tablename__ = "diaries"
    
    user_id: int = Field(foreign_key="users.id", index=True)
    ai_generated_text: Optional[str] = Field()
    is_public: bool = Field(default=False)
    keywords: Optional[str] = Field()  # JSON ì €ì¥
    
    # ê´€ê³„ ì„¤ì •
    user: "User" = Relationship(back_populates="diaries")
    images: List["Image"] = Relationship(back_populates="diary")

class DiaryCreate(DiaryBase):
    """ë‹¤ì´ì–´ë¦¬ ìƒì„± ìŠ¤í‚¤ë§ˆ"""
    pass

class DiaryUpdate(DiaryBase):
    """ë‹¤ì´ì–´ë¦¬ ì—…ë°ì´íŠ¸ ìŠ¤í‚¤ë§ˆ"""
    title: Optional[str] = None
    content: Optional[str] = None
    user_emotion: Optional[str] = None

# âŒ ì˜ëª»ëœ íŒ¨í„´
class Diary(SQLModel, table=True):
    id: int  # Field() ì‚¬ìš© ì•ˆí•¨, primary_key ëˆ„ë½
    title: str  # ê¸¸ì´ ì œí•œ ì—†ìŒ
    content: str  # ì¸ë±ìŠ¤ ê³ ë ¤ ì—†ìŒ
```

### ê´€ê³„ ì„¤ì • íŒ¨í„´

```python
# âœ… ì˜¬ë°”ë¥¸ ê´€ê³„ ì„¤ì •
from sqlmodel import Relationship
from typing import List, Optional

class User(BaseModel, table=True):
    __tablename__ = "users"
    
    email: str = Field(unique=True, index=True, max_length=255)
    provider: str = Field(max_length=20)
    
    # ê´€ê³„: ì‚¬ìš©ì -> ë‹¤ì´ì–´ë¦¬ (1:N)
    diaries: List["DiaryEntry"] = Relationship(back_populates="user")

class DiaryEntry(DiaryBase, BaseModel, table=True):
    __tablename__ = "diaries"
    
    user_id: int = Field(foreign_key="users.id", index=True)
    
    # ê´€ê³„: ë‹¤ì´ì–´ë¦¬ -> ì‚¬ìš©ì (N:1)
    user: "User" = Relationship(back_populates="diaries")
    # ê´€ê³„: ë‹¤ì´ì–´ë¦¬ -> ì´ë¯¸ì§€ (1:N)
    images: List["Image"] = Relationship(back_populates="diary")

# âŒ ì˜ëª»ëœ ê´€ê³„ ì„¤ì •
class User(SQLModel, table=True):
    diaries: List[DiaryEntry] = []  # Relationship() ì‚¬ìš© ì•ˆí•¨
```

### ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜ ê´€ë¦¬

```python
# âœ… ì˜¬ë°”ë¥¸ ì„¸ì…˜ ê´€ë¦¬ íŒ¨í„´
from sqlmodel import create_engine, Session, SQLModel
from app.core.config import settings

# ì—”ì§„ ìƒì„± (ì‹±ê¸€í†¤)
engine = create_engine(
    settings.DATABASE_URL,
    echo=settings.DATABASE_ECHO,
    pool_pre_ping=True,
    pool_recycle=3600,
)

def create_db_and_tables():
    """ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìƒì„±"""
    SQLModel.metadata.create_all(engine)

def get_session():
    """ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜ ì˜ì¡´ì„±"""
    with Session(engine) as session:
        yield session

# âœ… ì„œë¹„ìŠ¤ì—ì„œ ì„¸ì…˜ ì‚¬ìš©
class DiaryService:
    def __init__(self, session: Session):
        self.session = session
    
    async def create_diary(self, user_id: int, diary_in: DiaryCreate) -> DiaryEntry:
        diary = DiaryEntry(**diary_in.dict(), user_id=user_id)
        self.session.add(diary)
        self.session.commit()
        self.session.refresh(diary)
        return diary
```

## ğŸ“‹ API ì‘ë‹µ í‘œì¤€í™”

### ê¸°ë³¸ ì‘ë‹µ êµ¬ì¡°

```python
# âœ… í‘œì¤€í™”ëœ ì‘ë‹µ ëª¨ë¸
from typing import Optional, Any, List, Generic, TypeVar
from pydantic import BaseModel, Field
from datetime import datetime
import uuid

T = TypeVar('T')

class BaseResponse(BaseModel, Generic[T]):
    """ê¸°ë³¸ ì‘ë‹µ ëª¨ë¸"""
    success: bool = True
    data: Optional[T] = None
    message: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.now)
    request_id: str = Field(default_factory=lambda: str(uuid.uuid4()))

class ErrorDetail(BaseModel):
    """ì—ëŸ¬ ìƒì„¸ ì •ë³´"""
    code: str  # "AUTH_SOCIAL_PROVIDER_ERROR"
    error_id: int  # 1001
    field: Optional[str] = None
    message: str

class ErrorResponse(BaseModel):
    """ì—ëŸ¬ ì‘ë‹µ ëª¨ë¸"""
    success: bool = False
    data: Optional[Any] = None
    message: str
    errors: Optional[List[ErrorDetail]] = None
    timestamp: datetime = Field(default_factory=datetime.now)
    request_id: str = Field(default_factory=lambda: str(uuid.uuid4()))

class PaginationInfo(BaseModel):
    """í˜ì´ì§€ë„¤ì´ì…˜ ì •ë³´"""
    page: int = Field(ge=1)
    page_size: int = Field(ge=1, le=100)
    total_items: int = Field(ge=0)
    total_pages: int = Field(ge=0)
    has_next: bool
    has_previous: bool

class PaginatedResponse(BaseModel, Generic[T]):
    """í˜ì´ì§€ë„¤ì´ì…˜ ì‘ë‹µ ëª¨ë¸"""
    success: bool = True
    data: List[T]
    pagination: PaginationInfo
    message: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.now)
    request_id: str = Field(default_factory=lambda: str(uuid.uuid4()))

# âœ… ì‚¬ìš© ì˜ˆì‹œ
@router.get("/", response_model=BaseResponse[List[DiaryResponse]])
async def get_diaries(
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
) -> BaseResponse[List[DiaryResponse]]:
    diaries = session.exec(select(DiaryEntry).where(DiaryEntry.user_id == current_user.id)).all()
    diary_responses = [DiaryResponse.from_orm(diary) for diary in diaries]
    return BaseResponse(data=diary_responses, message="ë‹¤ì´ì–´ë¦¬ ëª©ë¡ ì¡°íšŒ ì„±ê³µ")
```

### ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´

```python
# âœ… êµ¬ì¡°í™”ëœ ì—ëŸ¬ ì²˜ë¦¬
from enum import Enum
from fastapi import HTTPException, status, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

class ErrorCode(str, Enum):
    """ì—ëŸ¬ ì½”ë“œ ì •ì˜"""
    # ì¸ì¦ ê´€ë ¨
    AUTH_SOCIAL_PROVIDER_ERROR = "AUTH_SOCIAL_PROVIDER_ERROR"
    AUTH_SOCIAL_TOKEN_INVALID = "AUTH_SOCIAL_TOKEN_INVALID" 
    AUTH_TOKEN_EXPIRED = "AUTH_TOKEN_EXPIRED"
    
    # ë‹¤ì´ì–´ë¦¬ ê´€ë ¨
    DIARY_NOT_FOUND = "DIARY_NOT_FOUND"
    DIARY_ACCESS_DENIED = "DIARY_ACCESS_DENIED"
    
    # AI ê´€ë ¨
    AI_SERVICE_UNAVAILABLE = "AI_SERVICE_UNAVAILABLE"
    AI_TOKEN_LIMIT_EXCEEDED = "AI_TOKEN_LIMIT_EXCEEDED"

# ì—ëŸ¬ ì½”ë“œ ë§¤í•‘
ERROR_MESSAGES = {
    ErrorCode.AUTH_SOCIAL_PROVIDER_ERROR: (1001, "ì†Œì…œ ë¡œê·¸ì¸ ì œê³µì ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."),
    ErrorCode.DIARY_NOT_FOUND: (2001, "ë‹¤ì´ì–´ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
    ErrorCode.AI_SERVICE_UNAVAILABLE: (3001, "AI ì„œë¹„ìŠ¤ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
}

def create_error_response(
    error_code: ErrorCode, 
    field: Optional[str] = None,
    custom_message: Optional[str] = None
) -> ErrorResponse:
    """ì—ëŸ¬ ì‘ë‹µ ìƒì„±"""
    error_id, default_message = ERROR_MESSAGES[error_code]
    message = custom_message or default_message
    
    return ErrorResponse(
        message="ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        errors=[ErrorDetail(
            code=error_code,
            error_id=error_id,
            field=field,
            message=message
        )]
    )

# ê¸€ë¡œë²Œ ì˜ˆì™¸ í•¸ë“¤ëŸ¬
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    errors = []
    for error in exc.errors():
        errors.append(ErrorDetail(
            code="VALIDATION_FAILED",
            error_id=5001,
            field=".".join(str(loc) for loc in error["loc"]),
            message=error["msg"]
        ))
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=ErrorResponse(
            message="ì…ë ¥ ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨",
            errors=errors
        ).dict()
    )
```

## ğŸ”’ ë³´ì•ˆ ê·œì¹™

### JWT ì¸ì¦ êµ¬í˜„

```python
# âœ… ì•ˆì „í•œ JWT êµ¬í˜„
import jwt
from datetime import datetime, timedelta
from passlib.context import CryptContext
from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """ë¹„ë°€ë²ˆí˜¸ í•´ì‹± (bcrypt, cost factor 12)"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """ë¹„ë°€ë²ˆí˜¸ ê²€ì¦"""
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """JWT ì•¡ì„¸ìŠ¤ í† í° ìƒì„±"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(hours=1)
    
    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow(),
        "jti": str(uuid.uuid4())
    })
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm="HS256")

def decode_access_token(token: str) -> dict:
    """JWT í† í° ë””ì½”ë”©"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤")
```

### ë°ì´í„° ì•”í˜¸í™”

```python
# âœ… ë°ì´í„° ì•”í˜¸í™” êµ¬í˜„
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import base64
import os

class DataEncryption:
    """AES-256-GCM ë°ì´í„° ì•”í˜¸í™”"""
    
    def __init__(self, key: bytes):
        self.cipher = AESGCM(key)
    
    def encrypt(self, plaintext: str) -> str:
        """ì•”í˜¸í™” (Base64 ì¸ì½”ë”©ëœ ë¬¸ìì—´ ë°˜í™˜)"""
        nonce = os.urandom(12)  # 96-bit nonce for GCM
        ciphertext = self.cipher.encrypt(nonce, plaintext.encode(), None)
        # nonce + ciphertextë¥¼ base64ë¡œ ì¸ì½”ë”©
        return base64.b64encode(nonce + ciphertext).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """ë³µí˜¸í™”"""
        data = base64.b64decode(encrypted_data.encode())
        nonce = data[:12]
        ciphertext = data[12:]
        plaintext = self.cipher.decrypt(nonce, ciphertext, None)
        return plaintext.decode()

# ì‚¬ìš© ì˜ˆì‹œ
encryptor = DataEncryption(settings.ENCRYPTION_KEY.encode())

class DiaryService:
    async def create_diary(self, user_id: int, diary_in: DiaryCreate) -> DiaryEntry:
        # ë¯¼ê°í•œ ë°ì´í„° ì•”í˜¸í™”
        encrypted_content = encryptor.encrypt(diary_in.content)
        
        diary = DiaryEntry(
            **diary_in.dict(exclude={"content"}),
            content=encrypted_content,
            user_id=user_id
        )
        # ... ì €ì¥ ë¡œì§
```

### ì…ë ¥ ê²€ì¦ ë° Sanitization

```python
# âœ… ì…ë ¥ ê²€ì¦ íŒ¨í„´
from pydantic import BaseModel, Field, validator, root_validator
from typing import Optional
import re

class DiaryCreate(BaseModel):
    """ë‹¤ì´ì–´ë¦¬ ìƒì„± ìŠ¤í‚¤ë§ˆ (ì…ë ¥ ê²€ì¦ í¬í•¨)"""
    title: str = Field(..., min_length=1, max_length=255, strip_whitespace=True)
    content: str = Field(..., min_length=1, max_length=10000, strip_whitespace=True)
    emotion: Optional[str] = Field(None, regex=r"^(happy|sad|angry|peaceful|worried)$")
    
    @validator('title', 'content')
    def validate_no_html(cls, v):
        """HTML íƒœê·¸ ì œê±°"""
        if re.search(r'<[^<]+?>', v):
            raise ValueError('HTML íƒœê·¸ëŠ” í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤')
        return v
    
    @validator('content')
    def validate_content_safety(cls, v):
        """ì•…ì„± ì½˜í…ì¸  ê²€ì¦"""
        dangerous_patterns = ['javascript:', 'data:', 'vbscript:']
        v_lower = v.lower()
        for pattern in dangerous_patterns:
            if pattern in v_lower:
                raise ValueError('í—ˆìš©ë˜ì§€ ì•ŠëŠ” ì½˜í…ì¸ ì…ë‹ˆë‹¤')
        return v

    @root_validator
    def validate_diary(cls, values):
        """ì „ì²´ ê²€ì¦"""
        title = values.get('title', '')
        content = values.get('content', '')
        
        if title.lower() in content.lower() and len(title) > 10:
            values['title'] = title[:50] + '...' if len(title) > 50 else title
        
        return values
```

## ğŸš« ê¸ˆì§€ ì‚¬í•­

### ì ˆëŒ€ í•˜ì§€ ë§ ê²ƒ

- **ë™ê¸° I/O ì‚¬ìš©**: `requests` ëŒ€ì‹  `httpx`, `psycopg2` ëŒ€ì‹  `asyncpg` ì‚¬ìš©
- **í‰ë¬¸ ë¹„ë°€ë²ˆí˜¸**: ëª¨ë“  ë¹„ë°€ë²ˆí˜¸ëŠ” bcryptë¡œ í•´ì‹±
- **í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿**: í™˜ê²½ë³€ìˆ˜ ë˜ëŠ” ë³´ì•ˆ ë³¼íŠ¸ ì‚¬ìš©
- **SQL ì¸ì ì…˜ ìœ„í—˜**: ì›ì‹œ SQL ì¿¼ë¦¬ ì‚¬ìš© ê¸ˆì§€, SQLModel ORM ì‚¬ìš©
- **íƒ€ì… íŒíŠ¸ ìƒëµ**: ëª¨ë“  í•¨ìˆ˜, ë³€ìˆ˜ì— íƒ€ì… íŒíŠ¸ í•„ìˆ˜
- **Exception ë¬´ì‹œ**: `pass`ë¡œ ì˜ˆì™¸ ì²˜ë¦¬ ê¸ˆì§€
- **ê¸€ë¡œë²Œ ë³€ìˆ˜**: ì˜ì¡´ì„± ì£¼ì… ì‚¬ìš©
- **ì„ì˜ ë°ì´í„° ë°˜í™˜**: ì •ì˜ëœ ìŠ¤í‚¤ë§ˆë§Œ ì‚¬ìš©

### FastAPI íŠ¹í™” ê¸ˆì§€ì‚¬í•­

- `@app.route()` ë°ì½”ë ˆì´í„° (Flask ìŠ¤íƒ€ì¼) ëŒ€ì‹  `@router.get()` ì‚¬ìš©
- ë¼ìš°í„° ì—†ì´ ì§ì ‘ ì•±ì— ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
- `response_model` ì—†ëŠ” API ì—”ë“œí¬ì¸íŠ¸
- ì˜ì¡´ì„± ì£¼ì… ì—†ì´ ì§ì ‘ ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼
- ë™ê¸° í•¨ìˆ˜ì—ì„œ ë¹„ë™ê¸° í•¨ìˆ˜ í˜¸ì¶œ

### ë³´ì•ˆ ê¸ˆì§€ì‚¬í•­

- ë¯¼ê°í•œ ì •ë³´ë¥¼ ë¡œê·¸ì— ê¸°ë¡ (ë¹„ë°€ë²ˆí˜¸, í† í°, ê°œì¸ì •ë³´)
- CORSì—ì„œ `allow_origins=["*"]` ì‚¬ìš© (í”„ë¡œë•ì…˜)
- ì•”í˜¸í™”ë˜ì§€ ì•Šì€ ë¯¼ê° ë°ì´í„° ì €ì¥
- JWT ì‹œí¬ë¦¿ì„ ì½”ë“œì— í•˜ë“œì½”ë”©
- ì‚¬ìš©ì ì…ë ¥ì„ ê²€ì¦ ì—†ì´ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥

## âœ… ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### ì„±ëŠ¥ ìµœì í™”

```python
# âœ… ë¹„ë™ê¸° ì²˜ë¦¬ íŒ¨í„´
import asyncio
import httpx
from typing import List

async def call_openai_api(prompt: str) -> str:
    """OpenAI API ë¹„ë™ê¸° í˜¸ì¶œ"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://api.openai.com/v1/completions",
            headers={"Authorization": f"Bearer {settings.OPENAI_API_KEY}"},
            json={"prompt": prompt, "max_tokens": 100},
            timeout=30.0
        )
        return response.json()["choices"][0]["text"]

# âœ… ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
async def get_user_diaries_optimized(
    session: Session, 
    user_id: int, 
    limit: int = 20
) -> List[DiaryEntry]:
    """ìµœì í™”ëœ ë‹¤ì´ì–´ë¦¬ ì¡°íšŒ (N+1 ë¬¸ì œ ë°©ì§€)"""
    statement = (
        select(DiaryEntry)
        .where(DiaryEntry.user_id == user_id)
        .options(selectinload(DiaryEntry.images))  # ê´€ë ¨ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë”©
        .order_by(DiaryEntry.created_at.desc())
        .limit(limit)
    )
    results = session.exec(statement)
    return results.all()

# âœ… ìºì‹± ì „ëµ
from functools import lru_cache
import redis

redis_client = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT)

@lru_cache(maxsize=128)
def get_emotion_keywords(emotion: str) -> List[str]:
    """ê°ì •ë³„ í‚¤ì›Œë“œ ìºì‹± (ë©”ëª¨ë¦¬)"""
    # ìºì‹œëœ í‚¤ì›Œë“œ ë°˜í™˜
    return EMOTION_KEYWORDS.get(emotion, [])

async def get_user_monthly_stats(user_id: int, year: int, month: int) -> dict:
    """ì‚¬ìš©ì ì›”ê°„ í†µê³„ (Redis ìºì‹±)"""
    cache_key = f"user_stats:{user_id}:{year}:{month}"
    cached = redis_client.get(cache_key)
    
    if cached:
        return json.loads(cached)
    
    # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê³„ì‚°
    stats = await calculate_monthly_stats(user_id, year, month)
    
    # 24ì‹œê°„ ìºì‹±
    redis_client.setex(cache_key, 86400, json.dumps(stats))
    return stats
```

### ì½”ë“œ í’ˆì§ˆ

```python
# âœ… ì„œë¹„ìŠ¤ ê³„ì¸µ ë¶„ë¦¬
class DiaryService:
    """ë‹¤ì´ì–´ë¦¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§"""
    
    def __init__(self, session: Session):
        self.session = session
        self.encryptor = DataEncryption(settings.ENCRYPTION_KEY.encode())
    
    async def create_diary(self, user_id: int, diary_in: DiaryCreate) -> DiaryEntry:
        """ë‹¤ì´ì–´ë¦¬ ìƒì„± (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)"""
        # 1. ì¼ì¼ ì‘ì„± í•œë„ í™•ì¸
        today_count = self._get_today_diary_count(user_id)
        if today_count >= settings.DAILY_DIARY_LIMIT:
            raise HTTPException(
                status_code=400,
                detail="ì¼ì¼ ë‹¤ì´ì–´ë¦¬ ì‘ì„± í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤."
            )
        
        # 2. ì½˜í…ì¸  ì•”í˜¸í™”
        encrypted_content = self.encryptor.encrypt(diary_in.content)
        
        # 3. AI ê°ì • ë¶„ì„ (ë¹„ë™ê¸°)
        ai_emotion, confidence = await self._analyze_emotion(diary_in.content)
        
        # 4. ë‹¤ì´ì–´ë¦¬ ìƒì„±
        diary = DiaryEntry(
            **diary_in.dict(exclude={"content"}),
            content=encrypted_content,
            ai_emotion=ai_emotion,
            ai_emotion_confidence=confidence,
            user_id=user_id
        )
        
        self.session.add(diary)
        self.session.commit()
        self.session.refresh(diary)
        
        # 5. ì›”ê°„ í†µê³„ ì—…ë°ì´íŠ¸ (ë°±ê·¸ë¼ìš´ë“œ)
        asyncio.create_task(self._update_monthly_stats(user_id, diary.user_emotion))
        
        return diary
    
    async def _analyze_emotion(self, content: str) -> Tuple[str, float]:
        """AI ê°ì • ë¶„ì„ (private ë©”ì„œë“œ)"""
        # AI ì„œë¹„ìŠ¤ í˜¸ì¶œ ë¡œì§
        pass
    
    def _get_today_diary_count(self, user_id: int) -> int:
        """ì˜¤ëŠ˜ ì‘ì„±í•œ ë‹¤ì´ì–´ë¦¬ ê°œìˆ˜"""
        today = datetime.now().date()
        return self.session.exec(
            select(func.count(DiaryEntry.id))
            .where(DiaryEntry.user_id == user_id)
            .where(func.date(DiaryEntry.created_at) == today)
        ).one()

# âœ… ì˜ì¡´ì„± ì£¼ì…ê³¼ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ì½”ë“œ
from abc import ABC, abstractmethod

class AIServiceInterface(ABC):
    """AI ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤"""
    
    @abstractmethod
    async def analyze_emotion(self, text: str) -> Tuple[str, float]:
        pass
    
    @abstractmethod
    async def generate_text(self, prompt: str, style: dict) -> str:
        pass

class OpenAIService(AIServiceInterface):
    """OpenAI êµ¬í˜„"""
    
    async def analyze_emotion(self, text: str) -> Tuple[str, float]:
        # OpenAI API í˜¸ì¶œ
        pass

class MockAIService(AIServiceInterface):
    """í…ŒìŠ¤íŠ¸ìš© Mock êµ¬í˜„"""
    
    async def analyze_emotion(self, text: str) -> Tuple[str, float]:
        return "happy", 0.8
```

### ë¡œê¹…ê³¼ ëª¨ë‹ˆí„°ë§

```python
# âœ… êµ¬ì¡°í™”ëœ ë¡œê¹…
import logging
import json
from datetime import datetime
from fastapi import Request

# ë¡œê·¸ ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

class StructuredLogger:
    """êµ¬ì¡°í™”ëœ ë¡œê¹…"""
    
    @staticmethod
    def log_api_request(request: Request, user_id: Optional[int] = None):
        """API ìš”ì²­ ë¡œê¹…"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "method": request.method,
            "url": str(request.url),
            "user_id": user_id,
            "user_agent": request.headers.get("user-agent"),
            "ip": request.client.host if request.client else None,
        }
        logger.info(f"API_REQUEST: {json.dumps(log_data)}")
    
    @staticmethod
    def log_error(error: Exception, context: dict = None):
        """ì—ëŸ¬ ë¡œê¹…"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "error_type": type(error).__name__,
            "error_message": str(error),
            "context": context or {},
        }
        logger.error(f"ERROR: {json.dumps(log_data)}")

# ë¯¸ë“¤ì›¨ì–´ë¡œ ì‚¬ìš©
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    start_time = datetime.now()
    
    # ìš”ì²­ ë¡œê¹…
    StructuredLogger.log_api_request(request)
    
    response = await call_next(request)
    
    # ì‘ë‹µ ì‹œê°„ ë¡œê¹…
    process_time = (datetime.now() - start_time).total_seconds()
    logger.info(f"REQUEST_COMPLETED: {request.method} {request.url} - {response.status_code} - {process_time:.3f}s")
    
    return response
```

## ğŸ¯ ìƒˆê¹€ í”„ë¡œì íŠ¸ íŠ¹í™” ê·œì¹™

### ê°ì • ë°ì´í„° ì²˜ë¦¬

```python
# âœ… ê°ì • íƒ€ì… ì •ì˜ ë° ê²€ì¦
from enum import Enum

class EmotionType(str, Enum):
    """ê°ì • íƒ€ì…"""
    HAPPY = "happy"
    SAD = "sad"
    ANGRY = "angry"
    PEACEFUL = "peaceful"
    WORRIED = "worried"

def is_valid_emotion(emotion: str) -> bool:
    """ê°ì • ìœ íš¨ì„± ê²€ì¦"""
    try:
        EmotionType(emotion)
        return True
    except ValueError:
        return False

# ê°ì •ë³„ ìƒ‰ìƒ ë§¤í•‘ (í”„ë¡ íŠ¸ì—”ë“œ ì—°ë™)
EMOTION_COLORS = {
    EmotionType.HAPPY: "#FFE066",
    EmotionType.SAD: "#87CEEB",
    EmotionType.ANGRY: "#FFB6C1",
    EmotionType.PEACEFUL: "#98FB98",
    EmotionType.WORRIED: "#DDA0DD",
}

# ê°ì •ë³„ í‚¤ì›Œë“œ ì¶”ì²œ
EMOTION_KEYWORDS = {
    EmotionType.HAPPY: ["ê¸°ì¨", "í–‰ë³µ", "ì¦ê±°ì›€", "ë§Œì¡±", "ì›ƒìŒ"],
    EmotionType.SAD: ["ìŠ¬í””", "ìš°ìš¸", "ì™¸ë¡œì›€", "ì•„ì‰¬ì›€", "ê·¸ë¦¬ì›€"],
    # ... ë‹¤ë¥¸ ê°ì •ë“¤
}
```

### AI ì„œë¹„ìŠ¤ ì—°ë™ íŒ¨í„´

```python
# âœ… AI ì„œë¹„ìŠ¤ ì œí•œ ë° ì—ëŸ¬ ì²˜ë¦¬
import asyncio
from typing import Dict, Any
import httpx

class AIService:
    """OpenAI API ì—°ë™ ì„œë¹„ìŠ¤"""
    
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=30.0)
        self.api_key = settings.OPENAI_API_KEY
        self.base_url = "https://api.openai.com/v1"
    
    async def generate_diary_text(
        self, 
        user_input: str, 
        emotion: EmotionType,
        style: Dict[str, Any]
    ) -> str:
        """ë‹¤ì´ì–´ë¦¬ ê¸€ê·€ ìƒì„±"""
        try:
            prompt = self._create_prompt(user_input, emotion, style)
            
            response = await self.client.post(
                f"{self.base_url}/completions",
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "gpt-3.5-turbo-instruct",
                    "prompt": prompt,
                    "max_tokens": style.get("length", 150),
                    "temperature": 0.7,
                    "top_p": 0.9,
                }
            )
            
            if response.status_code != 200:
                raise HTTPException(
                    status_code=503,
                    detail=create_error_response(ErrorCode.AI_SERVICE_UNAVAILABLE)
                )
            
            result = response.json()
            generated_text = result["choices"][0]["text"].strip()
            
            # í† í° ì‚¬ìš©ëŸ‰ ë¡œê¹…
            await self._log_ai_usage(user_input, generated_text, result["usage"])
            
            return generated_text
            
        except httpx.TimeoutException:
            raise HTTPException(
                status_code=503,
                detail="AI ì„œë¹„ìŠ¤ ì‘ë‹µ ì‹œê°„ ì´ˆê³¼"
            )
        except Exception as e:
            logger.error(f"AI ì„œë¹„ìŠ¤ í˜¸ì¶œ ì‹¤íŒ¨: {e}")
            raise HTTPException(
                status_code=503,
                detail="AI ì„œë¹„ìŠ¤ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
            )
    
    def _create_prompt(self, user_input: str, emotion: EmotionType, style: Dict) -> str:
        """í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        emotion_desc = {
            EmotionType.HAPPY: "ê¸°ì˜ê³  ë°ì€",
            EmotionType.SAD: "ìŠ¬í”„ê³  ì°¨ë¶„í•œ",
            # ... ë‹¤ë¥¸ ê°ì •ë“¤
        }
        
        return f"""
        ì‚¬ìš©ìì˜ ê°ì •: {emotion_desc.get(emotion, 'ì¤‘ë¦½ì ì¸')}
        ì‚¬ìš©ì ì…ë ¥: {user_input}
        
        ë‹¤ìŒ ì¡°ê±´ì— ë§ëŠ” í•œêµ­ì–´ ê¸€ê·€ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”:
        - í†¤: {style.get('tone', 'healing')}
        - ê¸¸ì´: {style.get('length_desc', 'ì ë‹¹í•œ ê¸¸ì´')}
        - í˜•ì‹: {style.get('type', 'prose')}
        
        ìƒì„±ëœ ê¸€ê·€:
        """
    
    async def _log_ai_usage(self, input_text: str, output_text: str, usage: dict):
        """AI ì‚¬ìš©ëŸ‰ ë¡œê¹…"""
        # ì‚¬ìš©ëŸ‰ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë¡
        pass
```

### ì†Œì…œ ì¸ì¦ ì²˜ë¦¬

```python
# âœ… ì†Œì…œ ì¸ì¦ í†µí•© ì²˜ë¦¬
from typing import Dict, Any
import httpx

class SocialAuthService:
    """ì†Œì…œ ì¸ì¦ í†µí•© ì„œë¹„ìŠ¤"""
    
    PROVIDERS = {
        "google": {
            "auth_url": "https://accounts.google.com/oauth2/auth",
            "token_url": "https://oauth2.googleapis.com/token",
            "user_info_url": "https://www.googleapis.com/oauth2/v2/userinfo"
        },
        "kakao": {
            "auth_url": "https://kauth.kakao.com/oauth/authorize",
            "token_url": "https://kauth.kakao.com/oauth/token",
            "user_info_url": "https://kapi.kakao.com/v2/user/me"
        },
        "naver": {
            "auth_url": "https://nid.naver.com/oauth2.0/authorize",
            "token_url": "https://nid.naver.com/oauth2.0/token", 
            "user_info_url": "https://openapi.naver.com/v1/nid/me"
        }
    }
    
    async def handle_callback(
        self, 
        provider: str, 
        code: str, 
        state: str
    ) -> Tuple[User, str, str]:
        """ì†Œì…œ ë¡œê·¸ì¸ ì½œë°± ì²˜ë¦¬"""
        if provider not in self.PROVIDERS:
            raise HTTPException(
                status_code=400,
                detail=create_error_response(
                    ErrorCode.AUTH_SOCIAL_PROVIDER_ERROR,
                    custom_message=f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì†Œì…œ ì œê³µì: {provider}"
                )
            )
        
        try:
            # 1. ì•¡ì„¸ìŠ¤ í† í° íšë“
            access_token = await self._get_access_token(provider, code)
            
            # 2. ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
            user_info = await self._get_user_info(provider, access_token)
            
            # 3. ì‚¬ìš©ì ìƒì„± ë˜ëŠ” ì¡°íšŒ
            user = await self._get_or_create_user(provider, user_info)
            
            # 4. JWT í† í° ìƒì„±
            access_token_jwt = create_access_token({"sub": str(user.id)})
            refresh_token_jwt = create_refresh_token({"sub": str(user.id)})
            
            return user, access_token_jwt, refresh_token_jwt
            
        except Exception as e:
            logger.error(f"ì†Œì…œ ì¸ì¦ ì²˜ë¦¬ ì‹¤íŒ¨ - Provider: {provider}, Error: {e}")
            raise HTTPException(
                status_code=400,
                detail=create_error_response(ErrorCode.AUTH_SOCIAL_TOKEN_INVALID)
            )
```

### ì•Œë¦¼ ì‹œìŠ¤í…œ

```python
# âœ… ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„
from enum import Enum
from datetime import datetime, time
import asyncio

class NotificationType(str, Enum):
    """ì•Œë¦¼ íƒ€ì…"""
    DIARY_REMINDER = "diary_reminder"
    REPORT_READY = "report_ready" 
    AI_COMPLETE = "ai_complete"

class NotificationService:
    """ì•Œë¦¼ ì„œë¹„ìŠ¤"""
    
    async def send_diary_reminder(self, user: User):
        """ë‹¤ì´ì–´ë¦¬ ì‘ì„± ì•Œë¦¼ ì „ì†¡"""
        if not await self._should_send_reminder(user):
            return
        
        notification = NotificationModel(
            user_id=user.id,
            type=NotificationType.DIARY_REMINDER,
            title="ë‹¤ì´ì–´ë¦¬ ì‘ì„± ì•Œë¦¼",
            message="ì˜¤ëŠ˜ì˜ ê°ì •ì„ ìƒˆê¹€ì— ê¸°ë¡í•´ë³´ì„¸ìš”.",
            scheduled_at=datetime.now()
        )
        
        # ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
        session.add(notification)
        session.commit()
        
        # ë¸Œë¼ìš°ì € í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡ (ë°±ê·¸ë¼ìš´ë“œ)
        asyncio.create_task(self._send_browser_push(user, notification))
    
    async def _should_send_reminder(self, user: User) -> bool:
        """ì•Œë¦¼ ì „ì†¡ ì—¬ë¶€ í™•ì¸"""
        # ì‚¬ìš©ì ì•Œë¦¼ ì„¤ì • í™•ì¸
        settings = await self._get_user_notification_settings(user.id)
        if not settings.diary_reminder_enabled:
            return False
        
        # ì˜¤ëŠ˜ ì´ë¯¸ ì‘ì„±í–ˆëŠ”ì§€ í™•ì¸
        today_diary_count = session.exec(
            select(func.count(DiaryEntry.id))
            .where(DiaryEntry.user_id == user.id)
            .where(func.date(DiaryEntry.created_at) == datetime.now().date())
        ).one()
        
        return today_diary_count == 0
```

ì´ ê·œì¹™ì„ ë”°ë¼ ì•ˆì „í•˜ê³  ê³ í’ˆì§ˆì˜ ìƒˆê¹€ ë°±ì—”ë“œ ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”!